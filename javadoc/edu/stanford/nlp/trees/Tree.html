<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_07) on Fri Jan 16 20:00:57 PST 2009 -->
<TITLE>
Tree (Stanford JavaNLP API)
</TITLE>

<META NAME="date" CONTENT="2009-01-16">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Tree (Stanford JavaNLP API)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/StringLabeledScoredTreeReaderFactory.html" title="class in edu.stanford.nlp.trees"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/TreeCoreAnnotations.html" title="class in edu.stanford.nlp.trees"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?edu/stanford/nlp/trees/Tree.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Tree.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
edu.stanford.nlp.trees</FONT>
<BR>
Class Tree</H2>
<PRE>
<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">java.lang.Object</A>
  <IMG SRC="../../../../resources/inherit.gif" ALT="extended by "><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractCollection.html?is-external=true" title="class or interface in java.util">java.util.AbstractCollection</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;
      <IMG SRC="../../../../resources/inherit.gif" ALT="extended by "><B>edu.stanford.nlp.trees.Tree</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</A>, <A HREF="../../../../edu/stanford/nlp/trees/Labeled.html" title="interface in edu.stanford.nlp.trees">Labeled</A>, <A HREF="../../../../edu/stanford/nlp/util/Scored.html" title="interface in edu.stanford.nlp.util">Scored</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/io/Serializable.html?is-external=true" title="class or interface in java.io">Serializable</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Iterable.html?is-external=true" title="class or interface in java.lang">Iterable</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Collection.html?is-external=true" title="class or interface in java.util">Collection</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;</DD>
</DL>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../../../edu/stanford/nlp/trees/LabeledScoredTreeLeaf.html" title="class in edu.stanford.nlp.trees">LabeledScoredTreeLeaf</A>, <A HREF="../../../../edu/stanford/nlp/trees/LabeledScoredTreeNode.html" title="class in edu.stanford.nlp.trees">LabeledScoredTreeNode</A>, <A HREF="../../../../edu/stanford/nlp/trees/SimpleTree.html" title="class in edu.stanford.nlp.trees">SimpleTree</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public abstract class <B>Tree</B><DT>extends <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractCollection.html?is-external=true" title="class or interface in java.util">AbstractCollection</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;<DT>implements <A HREF="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</A>, <A HREF="../../../../edu/stanford/nlp/trees/Labeled.html" title="interface in edu.stanford.nlp.trees">Labeled</A>, <A HREF="../../../../edu/stanford/nlp/util/Scored.html" title="interface in edu.stanford.nlp.util">Scored</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/io/Serializable.html?is-external=true" title="class or interface in java.io">Serializable</A></DL>
</PRE>

<P>
The abstract class <code>Tree</code> is used to collect all of the
 tree types, and acts as a generic extendable type.  This is the
 standard implementation of inheritance-based polymorphism.
 All <code>Tree</code> objects support accessors for their children (a
 <code>Tree[]</code>), their label (a <code>Label</code>), and their
 score (a <code>double</code>).  However, different concrete
 implementations may or may not include the latter two, in which
 case a default value is returned.  The class Tree defines no data
 fields.  The two abstract methods that must be implemented are:
 <code>children()</code>, and <code>treeFactory()</code>.  Note
 that <code>setChildren(Tree[])</code> is now an optional
 operation, whereas it was previously required to be
 implemented. There is now support for finding the parent of a
 tree.  This may be done by search from a tree root, or via a
 directly stored parent.  The <code>Tree</code> class now
 implements the <code>Collection</code> interface: in terms of
 this, each <i>node</i> of the tree is an element of the
 collection; hence one can explore the tree by using the methods of
 this interface.  A <code>Tree</code> is regarded as a read-only
 <code>Collection</code> (even though the <code>Tree</code> class
 has various methods that modify trees).  Moreover, the
 implementation is <i>not</i> thread-safe: no attempt is made to
 detect and report concurrent modifications.
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>Christopher Manning, Dan Klein, Sarah Spikes (sdspikes@cs.stanford.edu) - filled in types</DD>
<DT><B>See Also:</B><DD><A HREF="../../../../serialized-form.html#edu.stanford.nlp.trees.Tree">Serialized Form</A></DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#DISPLAY_SCORES">DISPLAY_SCORES</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#EMPTY_TREE_ARRAY">EMPTY_TREE_ARRAY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A leaf node should have a zero-length array for its
 children.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#Tree()">Tree</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#addChild(int, edu.stanford.nlp.trees.Tree)">addChild</A></B>(int&nbsp;i,
         <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds the tree t at the index position among the daughters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#addChild(edu.stanford.nlp.trees.Tree)">addChild</A></B>(<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds the tree t at the last index position among the daughters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#ancestor(int, edu.stanford.nlp.trees.Tree)">ancestor</A></B>(int&nbsp;height,
         <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;root)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the ancestor tree node <code>height</code> nodes up from the current node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#cCommands(edu.stanford.nlp.trees.Tree, edu.stanford.nlp.trees.Tree)">cCommands</A></B>(<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;t1,
          <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;t2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given nodes <code>t1</code> and <code>t2</code> which are
 dominated by this node, returns <code>true</code> iff
 <code>t1</code> c-commands <code>t2</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#children()">children</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an array of children for the current node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Constituent.html" title="class in edu.stanford.nlp.trees">Constituent</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#constituents()">constituents</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the Constituents generated by the parse tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Constituent.html" title="class in edu.stanford.nlp.trees">Constituent</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#constituents(edu.stanford.nlp.trees.ConstituentFactory)">constituents</A></B>(<A HREF="../../../../edu/stanford/nlp/trees/ConstituentFactory.html" title="interface in edu.stanford.nlp.trees">ConstituentFactory</A>&nbsp;cf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the Constituents generated by the parse tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#deepCopy()">deepCopy</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a deep copy of the tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#deepCopy(edu.stanford.nlp.trees.TreeFactory)">deepCopy</A></B>(<A HREF="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</A>&nbsp;tf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a deep copy of the tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#deeperCopy()">deeperCopy</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Same as deepCopy but makes a copy of the labels as well.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#deeperCopy(edu.stanford.nlp.trees.TreeFactory)">deeperCopy</A></B>(<A HREF="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</A>&nbsp;tf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Same as deepCopy but makes a copy of the labels as well.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#deeperCopy(edu.stanford.nlp.trees.TreeFactory, edu.stanford.nlp.ling.LabelFactory)">deeperCopy</A></B>(<A HREF="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</A>&nbsp;tf,
           <A HREF="../../../../edu/stanford/nlp/ling/LabelFactory.html" title="interface in edu.stanford.nlp.ling">LabelFactory</A>&nbsp;lf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Same as deepCopy but will copy the labels over as well.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#dependencies()">dependencies</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a set of Word-Word dependencies, represented as
 Dependency objects, for the Tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#dependencies(edu.stanford.nlp.util.Filter)">dependencies</A></B>(<A HREF="../../../../edu/stanford/nlp/util/Filter.html" title="interface in edu.stanford.nlp.util">Filter</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</A>&gt;&nbsp;f)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a set of Word-Word dependencies, represented as Dependency
 objects, for the Tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#dependencies(edu.stanford.nlp.util.Filter, edu.stanford.nlp.trees.HeadFinder)">dependencies</A></B>(<A HREF="../../../../edu/stanford/nlp/util/Filter.html" title="interface in edu.stanford.nlp.util">Filter</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</A>&gt;&nbsp;f,
             <A HREF="../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</A>&nbsp;hf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a set of Word-Word dependencies, represented as Dependency
 objects, for the Tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#dependencies(edu.stanford.nlp.trees.HeadFinder)">dependencies</A></B>(<A HREF="../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</A>&nbsp;hf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a set of Word-Word dependencies, represented as
 Dependency objects for the Tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#depth()">depth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finds the depth of the tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#depth(edu.stanford.nlp.trees.Tree)">depth</A></B>(<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;node)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finds the distance from this node to the specified node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#dominates(edu.stanford.nlp.trees.Tree)">dominates</A></B>(<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if <code>this</code> dominates the Tree passed in
 as an argument.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#dominationPath(edu.stanford.nlp.trees.Tree)">dominationPath</A></B>(<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the path of nodes leading down to a dominated node,
 including <code>this</code> and the dominated node itself.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#equals(java.lang.Object)">equals</A></B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</A>&nbsp;o)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implements equality for Tree's.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#firstChild()">firstChild</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the first child of a tree, or <code>null</code> if none.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#flatten()">flatten</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a flattened version of a tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#flatten(edu.stanford.nlp.trees.TreeFactory)">flatten</A></B>(<A HREF="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</A>&nbsp;tf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a flattened version of a tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#getChild(int)">getChild</A></B>(int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the child at some daughter index.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#getChildrenAsList()">getChildrenAsList</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a List of children for the current node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#getLeaves()">getLeaves</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the leaves of the tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#getLeaves(java.util.List)">getLeaves</A></B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;&nbsp;list)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the leaves of the tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#getNodeNumber(int)">getNodeNumber</A></B>(int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fetches the <code>i</code>th node in the tree, with node numbers defined
 as in <A HREF="../../../../edu/stanford/nlp/trees/Tree.html#nodeNumber(edu.stanford.nlp.trees.Tree)"><CODE>nodeNumber(Tree)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../edu/stanford/nlp/util/IntPair.html" title="class in edu.stanford.nlp.util">IntPair</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#getSpan()">getSpan</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#hashCode()">hashCode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implements a hashCode for Tree's.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#headPreTerminal(edu.stanford.nlp.trees.HeadFinder)">headPreTerminal</A></B>(<A HREF="../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</A>&nbsp;hf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the preterminal tree that is the head of the tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#headTerminal(edu.stanford.nlp.trees.HeadFinder)">headTerminal</A></B>(<A HREF="../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</A>&nbsp;hf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the tree leaf that is the head of the tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#headTerminal(edu.stanford.nlp.trees.HeadFinder, edu.stanford.nlp.trees.Tree)">headTerminal</A></B>(<A HREF="../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</A>&nbsp;hf,
             <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;parent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the tree leaf that is the head of the tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#indentedListPrint()">indentedListPrint</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indented list printing of a tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#indentedListPrint(java.io.PrintWriter, boolean)">indentedListPrint</A></B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/io/PrintWriter.html?is-external=true" title="class or interface in java.io">PrintWriter</A>&nbsp;pw,
                  boolean&nbsp;printScores)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indented list printing of a tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#indexLeaves()">indexLeaves</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assign sequential integer indices to the leaves of the tree
 rooted at this <code>Tree</code>, starting with 1.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#indexOf(edu.stanford.nlp.trees.Tree)">indexOf</A></B>(<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the position of a Tree in the children list, if present, or
 -1 if it is not present.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#insertDtr(edu.stanford.nlp.trees.Tree, int)">insertDtr</A></B>(<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;dtr,
          int&nbsp;position)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;insert <code>dtr</code> after <code>position</code> existing
 daughters in <code>this</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#isLeaf()">isLeaf</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Says whether a node is a leaf.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#isPhrasal()">isPhrasal</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return whether this node is a phrasal node or not.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#isPrePreTerminal()">isPrePreTerminal</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return whether all the children of this node are preterminals or not.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#isPreTerminal()">isPreTerminal</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return whether this node is a preterminal or not.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#isUnaryRewrite()">isUnaryRewrite</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Says whether the current node has only one child.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Iterator.html?is-external=true" title="class or interface in java.util">Iterator</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#iterator()">iterator</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an iterator over all the nodes of the tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#joinNode(edu.stanford.nlp.trees.Tree, edu.stanford.nlp.trees.Tree)">joinNode</A></B>(<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;t1,
         <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;t2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given nodes <code>t1</code> and <code>t2</code> which are
 dominated by this node, returns their "join node": the node
 <code>j</code> such that <code>j</code> dominates both
 <code>t1</code> and <code>t2</code>, and no other node which
 also dominates both <code>t1</code> and <code>t2</code>
 dominates <code>j</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#label()">label</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the label associated with the current node, or null
 if there is no label.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;<A HREF="../../../../edu/stanford/nlp/ling/LabeledWord.html" title="class in edu.stanford.nlp.ling">LabeledWord</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#labeledYield()">labeledYield</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;<A HREF="../../../../edu/stanford/nlp/ling/LabeledWord.html" title="class in edu.stanford.nlp.ling">LabeledWord</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#labeledYield(java.util.List)">labeledYield</A></B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;<A HREF="../../../../edu/stanford/nlp/ling/LabeledWord.html" title="class in edu.stanford.nlp.ling">LabeledWord</A>&gt;&nbsp;ty)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../edu/stanford/nlp/ling/LabelFactory.html" title="interface in edu.stanford.nlp.ling">LabelFactory</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#labelFactory()">labelFactory</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a factory that makes labels of the same type as this one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Collection.html?is-external=true" title="class or interface in java.util">Collection</A>&lt;<A HREF="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#labels()">labels</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the set of all node and leaf <code>Label</code>s,
 null or otherwise, contained in the tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#lastChild()">lastChild</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the last child of a tree, or <code>null</code> if none.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#leftCharEdge(edu.stanford.nlp.trees.Tree)">leftCharEdge</A></B>(<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;node)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the positional index of the left edge of  <i>node</i> within the tree,
 as measured by characters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#localTree()">localTree</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a new Tree that represents the local Tree at a certain node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#localTrees()">localTrees</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a set of one level <code>Tree</code>s that ares the local trees
 of the tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#mapDependencies(edu.stanford.nlp.util.Filter, edu.stanford.nlp.trees.HeadFinder)">mapDependencies</A></B>(<A HREF="../../../../edu/stanford/nlp/util/Filter.html" title="interface in edu.stanford.nlp.util">Filter</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</A>&gt;&nbsp;f,
                <A HREF="../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</A>&nbsp;hf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a set of Label-Label dependencies, represented as
 Dependency objects, for the Tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#nodeNumber(edu.stanford.nlp.trees.Tree)">nodeNumber</A></B>(<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;root)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculates the node's <i>number</i>, defined as the number of nodes traversed in a left-to-right, depth-first search of the
 tree starting at <code>root</code> and ending at <code>this</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#nodeString()">nodeString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the label of a tree node as a String.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#numChildren()">numChildren</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Says how many children a tree node has in its local tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#parent()">parent</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the parent of the tree node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#parent(edu.stanford.nlp.trees.Tree)">parent</A></B>(<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;root)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the parent of the tree node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#pathNodeToNode(edu.stanford.nlp.trees.Tree, edu.stanford.nlp.trees.Tree)">pathNodeToNode</A></B>(<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;t1,
               <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;t2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given nodes <code>t1</code> and <code>t2</code> which are
 dominated by this node, returns a list of all the nodes on the
 path from t1 to t2, inclusive, or null if none found.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#pennPrint()">pennPrint</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Print the tree as done in Penn Treebank merged files.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#pennPrint(java.io.PrintStream)">pennPrint</A></B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/io/PrintStream.html?is-external=true" title="class or interface in java.io">PrintStream</A>&nbsp;ps)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Print the tree as done in Penn Treebank merged files.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#pennPrint(java.io.PrintWriter)">pennPrint</A></B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/io/PrintWriter.html?is-external=true" title="class or interface in java.io">PrintWriter</A>&nbsp;pw)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Print the tree as done in Penn Treebank merged files.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#pennString()">pennString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calls <code>pennPrint()</code> and saves output to a String</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#percolateHeads(edu.stanford.nlp.trees.HeadFinder)">percolateHeads</A></B>(<A HREF="../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</A>&nbsp;hf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finds the heads of the tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;<A HREF="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#preTerminalYield()">preTerminalYield</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the preterminal yield (i.e., tags) of the tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;<A HREF="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#preTerminalYield(java.util.List)">preTerminalYield</A></B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;<A HREF="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</A>&gt;&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the preterminal yield (i.e., tags) of the tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#printLocalTree()">printLocalTree</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#printLocalTree(java.io.PrintWriter)">printLocalTree</A></B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/io/PrintWriter.html?is-external=true" title="class or interface in java.io">PrintWriter</A>&nbsp;pw)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#prune(edu.stanford.nlp.util.Filter)">prune</A></B>(<A HREF="../../../../edu/stanford/nlp/util/Filter.html" title="interface in edu.stanford.nlp.util">Filter</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;&nbsp;filter)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a deep copy of the tree, where all nodes that the filter
 does not accept and all children of such nodes are pruned.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#prune(edu.stanford.nlp.util.Filter, edu.stanford.nlp.trees.TreeFactory)">prune</A></B>(<A HREF="../../../../edu/stanford/nlp/util/Filter.html" title="interface in edu.stanford.nlp.util">Filter</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;&nbsp;filter,
      <A HREF="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</A>&nbsp;tf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a deep copy of the tree, where all nodes that the filter
 does not accept and all children of such nodes are pruned.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#removeChild(int)">removeChild</A></B>(int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Destructively removes the child at some daughter index and returns it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#rightCharEdge(edu.stanford.nlp.trees.Tree)">rightCharEdge</A></B>(<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;node)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the positional index of the right edge of  <i>node</i> within the tree,
 as measured by characters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#score()">score</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the score associated with the current node, or NaN
 if there is no score.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#setChild(int, edu.stanford.nlp.trees.Tree)">setChild</A></B>(int&nbsp;i,
         <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replaces the <code>i</code>th child of <code>this</code> with the tree t.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#setChildren(java.util.List)">setChildren</A></B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;&nbsp;childTreesList)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the children of this tree node to the given list.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#setChildren(edu.stanford.nlp.trees.Tree[])">setChildren</A></B>(<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>[]&nbsp;children)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the children of this node to be the children given in the
 array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#setFromString(java.lang.String)">setFromString</A></B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;labelStr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the contents of this label to this <code>String</code>
 representing the
 complete contents of the label.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#setLabel(edu.stanford.nlp.ling.Label)">setLabel</A></B>(<A HREF="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the label associated with the current node, if there is one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#setLabels(java.util.Collection)">setLabels</A></B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Collection.html?is-external=true" title="class or interface in java.util">Collection</A>&lt;<A HREF="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</A>&gt;&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the labels associated with this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#setScore(double)">setScore</A></B>(double&nbsp;score)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the score associated with the current node, if there is one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#setSpans()">setSpans</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#setValue(java.lang.String)">setValue</A></B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the value for the label (if one is stored).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#siblings(edu.stanford.nlp.trees.Tree)">siblings</A></B>(<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;root)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the siblings of this Tree node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#size()">size</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of nodes the tree contains.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#spliceOut(edu.stanford.nlp.util.Filter)">spliceOut</A></B>(<A HREF="../../../../edu/stanford/nlp/util/Filter.html" title="interface in edu.stanford.nlp.util">Filter</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;&nbsp;nodeFilter)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a (partial) deep copy of the tree, where all nodes that the
 filter does not accept are spliced out.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#spliceOut(edu.stanford.nlp.util.Filter, edu.stanford.nlp.trees.TreeFactory)">spliceOut</A></B>(<A HREF="../../../../edu/stanford/nlp/util/Filter.html" title="interface in edu.stanford.nlp.util">Filter</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;&nbsp;nodeFilter,
          <A HREF="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</A>&nbsp;tf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a (partial) deep copy of the tree, where all nodes that the
 filter does not accept are spliced out.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#subTreeList()">subTreeList</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the list of all subtrees inside the tree by returning a tree
 rooted at each node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#subTrees()">subTrees</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the set of all subtrees inside the tree by returning a tree
 rooted at each node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Collection.html?is-external=true" title="class or interface in java.util">Collection</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;&gt; 
<BR>
T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#subTrees(T)">subTrees</A></B>(T&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add the set of all subtrees inside a tree (including the tree itself)
 to the given <code>Collection</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#taggedDependencies()">taggedDependencies</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a Set of TaggedWord-TaggedWord dependencies, represented as
 Dependency objects, for the Tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#taggedDependencies(edu.stanford.nlp.util.Filter)">taggedDependencies</A></B>(<A HREF="../../../../edu/stanford/nlp/util/Filter.html" title="interface in edu.stanford.nlp.util">Filter</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</A>&gt;&nbsp;f)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a set of TaggedWord-TaggedWord dependencies, represented as
 Dependency objects, for the Tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#taggedDependencies(edu.stanford.nlp.util.Filter, edu.stanford.nlp.trees.HeadFinder)">taggedDependencies</A></B>(<A HREF="../../../../edu/stanford/nlp/util/Filter.html" title="interface in edu.stanford.nlp.util">Filter</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</A>&gt;&nbsp;f,
                   <A HREF="../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</A>&nbsp;hf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a set of TaggedWord-TaggedWord dependencies, represented as
 Dependency objects, for the Tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#taggedDependencies(edu.stanford.nlp.trees.HeadFinder)">taggedDependencies</A></B>(<A HREF="../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</A>&nbsp;hf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a set of TaggedWord-TaggedWord dependencies, represented as
 Dependency objects for the Tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../edu/stanford/nlp/ling/Sentence.html" title="class in edu.stanford.nlp.ling">Sentence</A>&lt;<A HREF="../../../../edu/stanford/nlp/ling/TaggedWord.html" title="class in edu.stanford.nlp.ling">TaggedWord</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#taggedYield()">taggedYield</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the tagged yield of the tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;X extends <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;<A HREF="../../../../edu/stanford/nlp/ling/TaggedWord.html" title="class in edu.stanford.nlp.ling">TaggedWord</A>&gt;&gt; 
<BR>
X</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#taggedYield(X)">taggedYield</A></B>(X&nbsp;ty)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the tagged yield of the tree -- that is, get the preterminals
 as well as the terminals.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts parse tree to string in Penn Treebank format.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/StringBuffer.html?is-external=true" title="class or interface in java.lang">StringBuffer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#toStringBuffer(java.lang.StringBuffer)">toStringBuffer</A></B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/StringBuffer.html?is-external=true" title="class or interface in java.lang">StringBuffer</A>&nbsp;sb)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Appends the printed form of a parse tree (as a bracketed String)
 to a <code>StringBuffer</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#toStructureDebugString()">toStructureDebugString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a String reporting what kinds of Tree and Label nodes this
  Tree contains.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#transform(edu.stanford.nlp.trees.TreeTransformer)">transform</A></B>(<A HREF="../../../../edu/stanford/nlp/trees/TreeTransformer.html" title="interface in edu.stanford.nlp.trees">TreeTransformer</A>&nbsp;transformer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a transformed Tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#transform(edu.stanford.nlp.trees.TreeTransformer, edu.stanford.nlp.trees.TreeFactory)">transform</A></B>(<A HREF="../../../../edu/stanford/nlp/trees/TreeTransformer.html" title="interface in edu.stanford.nlp.trees">TreeTransformer</A>&nbsp;transformer,
          <A HREF="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</A>&nbsp;tf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a transformed Tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#treeFactory()">treeFactory</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a <code>TreeFactory</code> that produces trees of the
 appropriate type.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#upperMostUnary(edu.stanford.nlp.trees.Tree)">upperMostUnary</A></B>(<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;root)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the highest node of the (perhaps trivial) unary chain that
  this node is part of.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#value()">value</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a String representation of just the "main" value of this label.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#valueOf(java.lang.String)">valueOf</A></B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;str)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This gives you a tree from a String representation (as a
 bracketed Tree, of the kind produced by <code>toString()</code>,
 <code>pennPrint()</code>, or as in the Penn Treebank).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#valueOf(java.lang.String, edu.stanford.nlp.trees.TreeReaderFactory)">valueOf</A></B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;str,
        <A HREF="../../../../edu/stanford/nlp/trees/TreeReaderFactory.html" title="interface in edu.stanford.nlp.trees">TreeReaderFactory</A>&nbsp;trf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This gives you a tree from a String representation (as a
 bracketed Tree, of the kind produced by <code>toString()</code>,
 <code>pennPrint()</code>, or as in the Penn Treebank.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;X extends <A HREF="../../../../edu/stanford/nlp/ling/HasWord.html" title="interface in edu.stanford.nlp.ling">HasWord</A>&gt; 
<BR>
<A HREF="../../../../edu/stanford/nlp/ling/Sentence.html" title="class in edu.stanford.nlp.ling">Sentence</A>&lt;X&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#yield()">yield</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the yield of the tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#yield(java.util.List)">yield</A></B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;T&gt;&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the yield of the tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;X extends <A HREF="../../../../edu/stanford/nlp/ling/HasWord.html" title="interface in edu.stanford.nlp.ling">HasWord</A>&gt; 
<BR>
<A HREF="../../../../edu/stanford/nlp/ling/Sentence.html" title="class in edu.stanford.nlp.ling">Sentence</A>&lt;X&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#yield(edu.stanford.nlp.ling.Sentence)">yield</A></B>(<A HREF="../../../../edu/stanford/nlp/ling/Sentence.html" title="class in edu.stanford.nlp.ling">Sentence</A>&lt;X&gt;&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the yield of the tree.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.util.AbstractCollection"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.util.<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractCollection.html?is-external=true" title="class or interface in java.util">AbstractCollection</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractCollection.html?is-external=true#add(E)" title="class or interface in java.util">add</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractCollection.html?is-external=true#addAll(java.util.Collection)" title="class or interface in java.util">addAll</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractCollection.html?is-external=true#clear()" title="class or interface in java.util">clear</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractCollection.html?is-external=true#contains(java.lang.Object)" title="class or interface in java.util">contains</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractCollection.html?is-external=true#containsAll(java.util.Collection)" title="class or interface in java.util">containsAll</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractCollection.html?is-external=true#isEmpty()" title="class or interface in java.util">isEmpty</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractCollection.html?is-external=true#remove(java.lang.Object)" title="class or interface in java.util">remove</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractCollection.html?is-external=true#removeAll(java.util.Collection)" title="class or interface in java.util">removeAll</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractCollection.html?is-external=true#retainAll(java.util.Collection)" title="class or interface in java.util">retainAll</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractCollection.html?is-external=true#toArray()" title="class or interface in java.util">toArray</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractCollection.html?is-external=true#toArray(T[])" title="class or interface in java.util">toArray</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html?is-external=true#clone()" title="class or interface in java.lang">clone</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html?is-external=true#finalize()" title="class or interface in java.lang">finalize</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html?is-external=true#getClass()" title="class or interface in java.lang">getClass</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html?is-external=true#notify()" title="class or interface in java.lang">notify</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html?is-external=true#notifyAll()" title="class or interface in java.lang">notifyAll</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html?is-external=true#wait()" title="class or interface in java.lang">wait</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html?is-external=true#wait(long)" title="class or interface in java.lang">wait</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html?is-external=true#wait(long, int)" title="class or interface in java.lang">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="EMPTY_TREE_ARRAY"><!-- --></A><H3>
EMPTY_TREE_ARRAY</H3>
<PRE>
public static final <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>[] <B>EMPTY_TREE_ARRAY</B></PRE>
<DL>
<DD>A leaf node should have a zero-length array for its
 children. For efficiency, classes can use this array as a
 return value for children() for leaf nodes if desired.
 This can also be used elsewhere when you want an empty Tree array.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="DISPLAY_SCORES"><!-- --></A><H3>
DISPLAY_SCORES</H3>
<PRE>
public static boolean <B>DISPLAY_SCORES</B></PRE>
<DL>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Tree()"><!-- --></A><H3>
Tree</H3>
<PRE>
public <B>Tree</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="isLeaf()"><!-- --></A><H3>
isLeaf</H3>
<PRE>
public boolean <B>isLeaf</B>()</PRE>
<DL>
<DD>Says whether a node is a leaf.  Can be used on an arbitrary
 <code>Tree</code>.  Being a leaf is defined as having no
 children.  This must be implemented as returning a zero-length
 Tree[] array for children().  This is the preferred
 alternative to running meta checks on types, as it works
 independent of Tree implementation.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true if this object is a leaf</DL>
</DD>
</DL>
<HR>

<A NAME="numChildren()"><!-- --></A><H3>
numChildren</H3>
<PRE>
public int <B>numChildren</B>()</PRE>
<DL>
<DD>Says how many children a tree node has in its local tree.
 Can be used on an arbitrary <code>Tree</code>.  Being a leaf is defined
 as having no children.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The number of direct children of the tree node</DL>
</DD>
</DL>
<HR>

<A NAME="isUnaryRewrite()"><!-- --></A><H3>
isUnaryRewrite</H3>
<PRE>
public boolean <B>isUnaryRewrite</B>()</PRE>
<DL>
<DD>Says whether the current node has only one child.
 Can be used on an arbitrary <code>Tree</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Whether the node heads a unary rewrite</DL>
</DD>
</DL>
<HR>

<A NAME="isPreTerminal()"><!-- --></A><H3>
isPreTerminal</H3>
<PRE>
public boolean <B>isPreTerminal</B>()</PRE>
<DL>
<DD>Return whether this node is a preterminal or not.  A preterminal is
 defined to be a node with one child which is itself a leaf.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true if the node is a preterminal; false otherwise</DL>
</DD>
</DL>
<HR>

<A NAME="isPrePreTerminal()"><!-- --></A><H3>
isPrePreTerminal</H3>
<PRE>
public boolean <B>isPrePreTerminal</B>()</PRE>
<DL>
<DD>Return whether all the children of this node are preterminals or not.
 A preterminal is
 defined to be a node with one child which is itself a leaf.
 Considered false if the node has no children
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true if the node is a prepreterminal; false otherwise</DL>
</DD>
</DL>
<HR>

<A NAME="isPhrasal()"><!-- --></A><H3>
isPhrasal</H3>
<PRE>
public boolean <B>isPhrasal</B>()</PRE>
<DL>
<DD>Return whether this node is a phrasal node or not.  A phrasal node
 is defined to be a node which is not a leaf or a preterminal.
 Worded positively, this means that it must have two or more children,
 or one child that is not a leaf.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD><code>true</code> if the node is phrasal;
         <code>false</code> otherwise</DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.lang.Object)"><!-- --></A><H3>
equals</H3>
<PRE>
public boolean <B>equals</B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</A>&nbsp;o)</PRE>
<DL>
<DD>Implements equality for Tree's.  Two Tree objects are equal if they
 have equal Labels, the same number of children, and their children
 are pairwise equal.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Collection.html?is-external=true#equals(java.lang.Object)" title="class or interface in java.util">equals</A></CODE> in interface <CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Collection.html?is-external=true" title="class or interface in java.util">Collection</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;</CODE><DT><B>Overrides:</B><DD><CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html?is-external=true#equals(java.lang.Object)" title="class or interface in java.lang">equals</A></CODE> in class <CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>o</CODE> - The object to compare with
<DT><B>Returns:</B><DD>Whether two things are equal</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode()"><!-- --></A><H3>
hashCode</H3>
<PRE>
public int <B>hashCode</B>()</PRE>
<DL>
<DD>Implements a hashCode for Tree's.  Two trees should have the same
 hashcode if they are equal, so we hash on the label, the label and
 the children's labels.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Collection.html?is-external=true#hashCode()" title="class or interface in java.util">hashCode</A></CODE> in interface <CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Collection.html?is-external=true" title="class or interface in java.util">Collection</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;</CODE><DT><B>Overrides:</B><DD><CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html?is-external=true#hashCode()" title="class or interface in java.lang">hashCode</A></CODE> in class <CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The hash code</DL>
</DD>
</DL>
<HR>

<A NAME="indexOf(edu.stanford.nlp.trees.Tree)"><!-- --></A><H3>
indexOf</H3>
<PRE>
public int <B>indexOf</B>(<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;tree)</PRE>
<DL>
<DD>Returns the position of a Tree in the children list, if present, or
 -1 if it is not present.  Trees are checked for presence with
 <code>equals()</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tree</CODE> - The tree to look for in children list
<DT><B>Returns:</B><DD>Its index in the list or -1</DL>
</DD>
</DL>
<HR>

<A NAME="children()"><!-- --></A><H3>
children</H3>
<PRE>
public abstract <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>[] <B>children</B>()</PRE>
<DL>
<DD>Returns an array of children for the current node.  If there
 are no children (if the node is a leaf), this must return a
 Tree[] array of length 0.  A null children() value for tree
 leaves was previously supported, but no longer is.
 A caller may assume that either <code>isLeaf()</code> returns
 true, or this node has a nonzero number of children.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The children of the node<DT><B>See Also:</B><DD><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#getChildrenAsList()"><CODE>getChildrenAsList()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getChildrenAsList()"><!-- --></A><H3>
getChildrenAsList</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt; <B>getChildrenAsList</B>()</PRE>
<DL>
<DD>Returns a List of children for the current node.  If there are no
 children, then a (non-null) <code>List&lt;Tree&gt;</code> of size 0 will
 be returned.  The list has new list structure but pointers to,
 not copies of the children.  That is, the returned list is mutable,
 and simply adding to or deleting items from it is safe, but beware
 changing the contents of the children.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The children of the node</DL>
</DD>
</DL>
<HR>

<A NAME="setChildren(edu.stanford.nlp.trees.Tree[])"><!-- --></A><H3>
setChildren</H3>
<PRE>
public void <B>setChildren</B>(<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>[]&nbsp;children)</PRE>
<DL>
<DD>Set the children of this node to be the children given in the
 array.  This is an <b>optional</b> operation; by default it is
 unsupported.  Note for subclasses that if there are no
 children, the children() method must return a Tree[] array of
 length 0.  This class gives subclasses access to a protected
 <code>ZEROCHILDREN</code> canonical zero-length Tree[] array
 to represent zero children, but it is <i>not</i> required that
 leaf nodes use this particular zero-length array to represent
 a leaf node.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>children</CODE> - The array of children, each a <code>Tree</code><DT><B>See Also:</B><DD><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#setChildren(java.util.List)"><CODE>setChildren(List)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setChildren(java.util.List)"><!-- --></A><H3>
setChildren</H3>
<PRE>
public void <B>setChildren</B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;&nbsp;childTreesList)</PRE>
<DL>
<DD>Set the children of this tree node to the given list.  This
 method is implemented in the <code>Tree</code> class by
 converting the <code>List</code> into a tree array and calling
 the array-based method.  Subclasses which use a
 <code>List</code>-based representation of tree children should
 override this method.  This implementation allows the case
 that the <code>List</code> is <code>null</code>: it yields a
 node with no children (represented by a canonical zero-length
 children() array).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>childTreesList</CODE> - A list of trees to become children of the node.
          This method does not retain the List that you pass it (copying
          is done), but it will retain the individual children (they are
          not copied).<DT><B>See Also:</B><DD><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#setChildren(edu.stanford.nlp.trees.Tree[])"><CODE>setChildren(Tree[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="label()"><!-- --></A><H3>
label</H3>
<PRE>
public <A HREF="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</A> <B>label</B>()</PRE>
<DL>
<DD>Returns the label associated with the current node, or null
 if there is no label.  The default implementation always
 returns <code>null</code>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../edu/stanford/nlp/trees/Labeled.html#label()">label</A></CODE> in interface <CODE><A HREF="../../../../edu/stanford/nlp/trees/Labeled.html" title="interface in edu.stanford.nlp.trees">Labeled</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The label of the node</DL>
</DD>
</DL>
<HR>

<A NAME="setLabel(edu.stanford.nlp.ling.Label)"><!-- --></A><H3>
setLabel</H3>
<PRE>
public void <B>setLabel</B>(<A HREF="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</A>&nbsp;label)</PRE>
<DL>
<DD>Sets the label associated with the current node, if there is one.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../edu/stanford/nlp/trees/Labeled.html#setLabel(edu.stanford.nlp.ling.Label)">setLabel</A></CODE> in interface <CODE><A HREF="../../../../edu/stanford/nlp/trees/Labeled.html" title="interface in edu.stanford.nlp.trees">Labeled</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>label</CODE> - The label</DL>
</DD>
</DL>
<HR>

<A NAME="score()"><!-- --></A><H3>
score</H3>
<PRE>
public double <B>score</B>()</PRE>
<DL>
<DD>Returns the score associated with the current node, or NaN
 if there is no score.  The default implementation returns NaN.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../edu/stanford/nlp/util/Scored.html#score()">score</A></CODE> in interface <CODE><A HREF="../../../../edu/stanford/nlp/util/Scored.html" title="interface in edu.stanford.nlp.util">Scored</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The score</DL>
</DD>
</DL>
<HR>

<A NAME="setScore(double)"><!-- --></A><H3>
setScore</H3>
<PRE>
public void <B>setScore</B>(double&nbsp;score)</PRE>
<DL>
<DD>Sets the score associated with the current node, if there is one.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>score</CODE> - The score</DL>
</DD>
</DL>
<HR>

<A NAME="firstChild()"><!-- --></A><H3>
firstChild</H3>
<PRE>
public <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> <B>firstChild</B>()</PRE>
<DL>
<DD>Returns the first child of a tree, or <code>null</code> if none.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The first child</DL>
</DD>
</DL>
<HR>

<A NAME="lastChild()"><!-- --></A><H3>
lastChild</H3>
<PRE>
public <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> <B>lastChild</B>()</PRE>
<DL>
<DD>Returns the last child of a tree, or <code>null</code> if none.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The last child</DL>
</DD>
</DL>
<HR>

<A NAME="upperMostUnary(edu.stanford.nlp.trees.Tree)"><!-- --></A><H3>
upperMostUnary</H3>
<PRE>
public <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> <B>upperMostUnary</B>(<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;root)</PRE>
<DL>
<DD>Return the highest node of the (perhaps trivial) unary chain that
  this node is part of.
  In case this node is the only child of its parent, trace up the chain of
  unaries, and return the uppermost node of the chain (the node whose
  parent has multiple children, or the node that is the root of the tree).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>root</CODE> - The root of the tree that contains this subtree
<DT><B>Returns:</B><DD>The uppermost node of the unary chain, if this node is in a unary
         chain, or else the current node</DL>
</DD>
</DL>
<HR>

<A NAME="setSpans()"><!-- --></A><H3>
setSpans</H3>
<PRE>
public void <B>setSpans</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSpan()"><!-- --></A><H3>
getSpan</H3>
<PRE>
public <A HREF="../../../../edu/stanford/nlp/util/IntPair.html" title="class in edu.stanford.nlp.util">IntPair</A> <B>getSpan</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="constituents()"><!-- --></A><H3>
constituents</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Constituent.html" title="class in edu.stanford.nlp.trees">Constituent</A>&gt; <B>constituents</B>()</PRE>
<DL>
<DD>Returns the Constituents generated by the parse tree.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a Set of the constituents as constituents of
         type <code>Constituent</code></DL>
</DD>
</DL>
<HR>

<A NAME="constituents(edu.stanford.nlp.trees.ConstituentFactory)"><!-- --></A><H3>
constituents</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Constituent.html" title="class in edu.stanford.nlp.trees">Constituent</A>&gt; <B>constituents</B>(<A HREF="../../../../edu/stanford/nlp/trees/ConstituentFactory.html" title="interface in edu.stanford.nlp.trees">ConstituentFactory</A>&nbsp;cf)</PRE>
<DL>
<DD>Returns the Constituents generated by the parse tree.
 The Constituents of a sentence include the preterminal categories
 but not the leaves.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cf</CODE> - ConstituentFactory used to build the Constituent objects
<DT><B>Returns:</B><DD>a Set of the constituents as SimpleConstituent type
         (in the current implementation, a <code>HashSet</code></DL>
</DD>
</DL>
<HR>

<A NAME="localTree()"><!-- --></A><H3>
localTree</H3>
<PRE>
public <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> <B>localTree</B>()</PRE>
<DL>
<DD>Returns a new Tree that represents the local Tree at a certain node.
 That is, it builds a new tree that copies the mother and daughter
 nodes (but not their Labels), as non-Leaf nodes,
 but zeroes out their children.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>A local tree</DL>
</DD>
</DL>
<HR>

<A NAME="localTrees()"><!-- --></A><H3>
localTrees</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt; <B>localTrees</B>()</PRE>
<DL>
<DD>Returns a set of one level <code>Tree</code>s that ares the local trees
 of the tree.
 That is, it builds a new tree that copies the mother and daughter
 nodes (but not their Labels), for each phrasal node,
 but zeroes out their children.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>A set of local tree</DL>
</DD>
</DL>
<HR>

<A NAME="toStructureDebugString()"><!-- --></A><H3>
toStructureDebugString</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A> <B>toStructureDebugString</B>()</PRE>
<DL>
<DD>Returns a String reporting what kinds of Tree and Label nodes this
  Tree contains.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="toStringBuffer(java.lang.StringBuffer)"><!-- --></A><H3>
toStringBuffer</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/StringBuffer.html?is-external=true" title="class or interface in java.lang">StringBuffer</A> <B>toStringBuffer</B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/StringBuffer.html?is-external=true" title="class or interface in java.lang">StringBuffer</A>&nbsp;sb)</PRE>
<DL>
<DD>Appends the printed form of a parse tree (as a bracketed String)
 to a <code>StringBuffer</code>.
 The implementation of this may be more efficient than for
 <code>toString()</code> on complex trees.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sb</CODE> - The StringBuffer  to append to
<DT><B>Returns:</B><DD>StringBuffer returns the <code>StringBuffer</code></DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A> <B>toString</B>()</PRE>
<DL>
<DD>Converts parse tree to string in Penn Treebank format.
 Get efficiency by chaining a single <code>StringBuffer</code>
 through it all.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../edu/stanford/nlp/ling/Label.html#toString()">toString</A></CODE> in interface <CODE><A HREF="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</A></CODE><DT><B>Overrides:</B><DD><CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractCollection.html?is-external=true#toString()" title="class or interface in java.util">toString</A></CODE> in class <CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractCollection.html?is-external=true" title="class or interface in java.util">AbstractCollection</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the tree as a bracketed list on one line</DL>
</DD>
</DL>
<HR>

<A NAME="printLocalTree()"><!-- --></A><H3>
printLocalTree</H3>
<PRE>
public void <B>printLocalTree</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="printLocalTree(java.io.PrintWriter)"><!-- --></A><H3>
printLocalTree</H3>
<PRE>
public void <B>printLocalTree</B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/io/PrintWriter.html?is-external=true" title="class or interface in java.io">PrintWriter</A>&nbsp;pw)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="indentedListPrint()"><!-- --></A><H3>
indentedListPrint</H3>
<PRE>
public void <B>indentedListPrint</B>()</PRE>
<DL>
<DD>Indented list printing of a tree.  The tree is printed in an
 indented list notation, with nodel labels followed by node scores.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="indentedListPrint(java.io.PrintWriter, boolean)"><!-- --></A><H3>
indentedListPrint</H3>
<PRE>
public void <B>indentedListPrint</B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/io/PrintWriter.html?is-external=true" title="class or interface in java.io">PrintWriter</A>&nbsp;pw,
                              boolean&nbsp;printScores)</PRE>
<DL>
<DD>Indented list printing of a tree.  The tree is printed in an
 indented list notation, with nodel labels followed by node scores.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pw</CODE> - The PrintWriter to print the tree to<DD><CODE>printScores</CODE> - Whether to print the scores (log probs) of tree nodes</DL>
</DD>
</DL>
<HR>

<A NAME="nodeString()"><!-- --></A><H3>
nodeString</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A> <B>nodeString</B>()</PRE>
<DL>
<DD>Returns the label of a tree node as a String.  This is done by
  calling <code>toString()</code> on the Label, but if the label is
  <code>null</code> or has a <code>null</code>, value,
  then this method returns an empty String.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The label of a tree node as a String</DL>
</DD>
</DL>
<HR>

<A NAME="pennPrint(java.io.PrintWriter)"><!-- --></A><H3>
pennPrint</H3>
<PRE>
public void <B>pennPrint</B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/io/PrintWriter.html?is-external=true" title="class or interface in java.io">PrintWriter</A>&nbsp;pw)</PRE>
<DL>
<DD>Print the tree as done in Penn Treebank merged files.
 The formatting should be exactly the same, but we don't print the
 trailing whitespace found in Penn Treebank trees.
 The basic deviation from a bracketed indented tree is to in general
 collapse the printing of adjacent preterminals onto one line of
 tasg and words.  Additional complexities are that conjunctions
 (tag CC) are not collapsed in this way, and that the unlabeled
 outer brackets are collapsed onto the same line as the next
 bracket down.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pw</CODE> - The tree is printed to this <code>PrintWriter</code></DL>
</DD>
</DL>
<HR>

<A NAME="pennPrint(java.io.PrintStream)"><!-- --></A><H3>
pennPrint</H3>
<PRE>
public void <B>pennPrint</B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/io/PrintStream.html?is-external=true" title="class or interface in java.io">PrintStream</A>&nbsp;ps)</PRE>
<DL>
<DD>Print the tree as done in Penn Treebank merged files.
 The formatting should be exactly the same, but we don't print the
 trailing whitespace found in Penn Treebank trees.
 The basic deviation from a bracketed indented tree is to in general
 collapse the printing of adjacent preterminals onto one line of
 tags and words.  Additional complexities are that conjunctions
 (tag CC) are not collapsed in this way, and that the unlabeled
 outer brackets are collapsed onto the same line as the next
 bracket down.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ps</CODE> - The tree is printed to this <code>PrintStream</code></DL>
</DD>
</DL>
<HR>

<A NAME="pennString()"><!-- --></A><H3>
pennString</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A> <B>pennString</B>()</PRE>
<DL>
<DD>Calls <code>pennPrint()</code> and saves output to a String
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The indent S-expression representation of a Tree</DL>
</DD>
</DL>
<HR>

<A NAME="pennPrint()"><!-- --></A><H3>
pennPrint</H3>
<PRE>
public void <B>pennPrint</B>()</PRE>
<DL>
<DD>Print the tree as done in Penn Treebank merged files.
 The formatting should be exactly the same, but we don't print the
 trailing whitespace found in Penn Treebank trees.
 The tree is printed to <code>System.out</code>. The basic deviation
 from a bracketed indented tree is to in general
 collapse the printing of adjacent preterminals onto one line of
 tags and words.  Additional complexities are that conjunctions
 (tag CC) are not collapsed in this way, and that the unlabeled
 outer brackets are collapsed onto the same line as the next
 bracket down.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="depth()"><!-- --></A><H3>
depth</H3>
<PRE>
public int <B>depth</B>()</PRE>
<DL>
<DD>Finds the depth of the tree.  The depth is defined as the length
 of the longest path from this node to a leaf node.  Leaf nodes
 have depth zero.  POS tags have depth 1. Phrasal nodes have
 depth &gt;= 2.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the depth</DL>
</DD>
</DL>
<HR>

<A NAME="depth(edu.stanford.nlp.trees.Tree)"><!-- --></A><H3>
depth</H3>
<PRE>
public int <B>depth</B>(<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;node)</PRE>
<DL>
<DD>Finds the distance from this node to the specified node.
 return -1 if this is not an ancestor of node.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>node</CODE> - A subtree contained in this tree
<DT><B>Returns:</B><DD>the depth</DL>
</DD>
</DL>
<HR>

<A NAME="headTerminal(edu.stanford.nlp.trees.HeadFinder, edu.stanford.nlp.trees.Tree)"><!-- --></A><H3>
headTerminal</H3>
<PRE>
public <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> <B>headTerminal</B>(<A HREF="../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</A>&nbsp;hf,
                         <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;parent)</PRE>
<DL>
<DD>Returns the tree leaf that is the head of the tree.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hf</CODE> - The headfinding algorithm to use<DD><CODE>parent</CODE> - The parent of this tree
<DT><B>Returns:</B><DD>The head tree leaf if any, else <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="headTerminal(edu.stanford.nlp.trees.HeadFinder)"><!-- --></A><H3>
headTerminal</H3>
<PRE>
public <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> <B>headTerminal</B>(<A HREF="../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</A>&nbsp;hf)</PRE>
<DL>
<DD>Returns the tree leaf that is the head of the tree.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hf</CODE> - The headfinding algorithm to use
<DT><B>Returns:</B><DD>The head tree leaf if any, else <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="headPreTerminal(edu.stanford.nlp.trees.HeadFinder)"><!-- --></A><H3>
headPreTerminal</H3>
<PRE>
public <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> <B>headPreTerminal</B>(<A HREF="../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</A>&nbsp;hf)</PRE>
<DL>
<DD>Returns the preterminal tree that is the head of the tree.
 See <A HREF="../../../../edu/stanford/nlp/trees/Tree.html#isPreTerminal()"><CODE>isPreTerminal()</CODE></A> for
 the definition of a preterminal node. Beware that some tree nodes may
 have no preterminal head.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hf</CODE> - The headfinding algorithm to use
<DT><B>Returns:</B><DD>The head preterminal tree, if any, else <code>null</code>
<DT><B>Throws:</B>
<DD><CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/IllegalArgumentException.html?is-external=true" title="class or interface in java.lang">IllegalArgumentException</A></CODE> - if called on a leaf node</DL>
</DD>
</DL>
<HR>

<A NAME="percolateHeads(edu.stanford.nlp.trees.HeadFinder)"><!-- --></A><H3>
percolateHeads</H3>
<PRE>
public void <B>percolateHeads</B>(<A HREF="../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</A>&nbsp;hf)</PRE>
<DL>
<DD>Finds the heads of the tree.  This code assumes that the label
 does store and return sensible values for the category, word, and tag.
 It will be a no-op otherwise.  The tree is modified.  The routine
 assumes the Tree has word leaves and tag preterminals, and copies
 their category to word and tag respectively, if they have a null
 value.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hf</CODE> - The headfinding algorithm to use</DL>
</DD>
</DL>
<HR>

<A NAME="dependencies()"><!-- --></A><H3>
dependencies</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</A>&gt; <B>dependencies</B>()</PRE>
<DL>
<DD>Return a set of Word-Word dependencies, represented as
 Dependency objects, for the Tree.  This will only give
 useful results if the internal tree node labels support HasWord and
 head percolation has already been done (see percolateHeads()).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Set of dependencies (each a Dependency)</DL>
</DD>
</DL>
<HR>

<A NAME="dependencies(edu.stanford.nlp.util.Filter)"><!-- --></A><H3>
dependencies</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</A>&gt; <B>dependencies</B>(<A HREF="../../../../edu/stanford/nlp/util/Filter.html" title="interface in edu.stanford.nlp.util">Filter</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</A>&gt;&nbsp;f)</PRE>
<DL>
<DD>Return a set of Word-Word dependencies, represented as Dependency
 objects, for the Tree.  This will only give
 useful results if the internal tree node labels support HasWord and
 head percolation has already been done (see percolateHeads()).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>f</CODE> - Dependencies are excluded for which the Dependency is not
          accepted by the Filter
<DT><B>Returns:</B><DD>Set of dependencies (each a Dependency)</DL>
</DD>
</DL>
<HR>

<A NAME="dependencies(edu.stanford.nlp.trees.HeadFinder)"><!-- --></A><H3>
dependencies</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</A>&gt; <B>dependencies</B>(<A HREF="../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</A>&nbsp;hf)</PRE>
<DL>
<DD>Return a set of Word-Word dependencies, represented as
 Dependency objects for the Tree.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hf</CODE> - The HeadFinder to use to identify the head of constituents
<DT><B>Returns:</B><DD>Set of dependencies (each a <code>Dependency</code>)</DL>
</DD>
</DL>
<HR>

<A NAME="dependencies(edu.stanford.nlp.util.Filter, edu.stanford.nlp.trees.HeadFinder)"><!-- --></A><H3>
dependencies</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</A>&gt; <B>dependencies</B>(<A HREF="../../../../edu/stanford/nlp/util/Filter.html" title="interface in edu.stanford.nlp.util">Filter</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</A>&gt;&nbsp;f,
                                    <A HREF="../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</A>&nbsp;hf)</PRE>
<DL>
<DD>Return a set of Word-Word dependencies, represented as Dependency
 objects, for the Tree.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>f</CODE> - Dependencies are excluded for which the Dependency is not
           accepted by the Filter<DD><CODE>hf</CODE> - The HeadFinder to use to identify the head of constituents.
           If this is <code>null</code>, then nodes are assumed to already
           be marked with their heads.
<DT><B>Returns:</B><DD>Set of dependencies (each a <code>Dependency</code>)</DL>
</DD>
</DL>
<HR>

<A NAME="taggedDependencies()"><!-- --></A><H3>
taggedDependencies</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</A>&gt; <B>taggedDependencies</B>()</PRE>
<DL>
<DD>Return a Set of TaggedWord-TaggedWord dependencies, represented as
 Dependency objects, for the Tree.  This will only give
 useful results if the internal tree node labels support HasWord and
 HasTag, and head percolation has already been done (see
 percolateHeads()).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Set of dependencies (each a Dependency)</DL>
</DD>
</DL>
<HR>

<A NAME="taggedDependencies(edu.stanford.nlp.util.Filter)"><!-- --></A><H3>
taggedDependencies</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</A>&gt; <B>taggedDependencies</B>(<A HREF="../../../../edu/stanford/nlp/util/Filter.html" title="interface in edu.stanford.nlp.util">Filter</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</A>&gt;&nbsp;f)</PRE>
<DL>
<DD>Return a set of TaggedWord-TaggedWord dependencies, represented as
 Dependency objects, for the Tree.  This will only give
 useful results if the internal tree node labels support HasWord and
 head percolation has already been done (see percolateHeads()).
 <p><i>Implementation note:</i> It would be nice to generalize this with
 dependencies() to use a LabelFactory, but it seems impossible with the
 current setup.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>f</CODE> - Dependencies are excluded for which the Dependency is not
          accepted by the Filter
<DT><B>Returns:</B><DD>Set of dependencies (each a Dependency)</DL>
</DD>
</DL>
<HR>

<A NAME="taggedDependencies(edu.stanford.nlp.trees.HeadFinder)"><!-- --></A><H3>
taggedDependencies</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</A>&gt; <B>taggedDependencies</B>(<A HREF="../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</A>&nbsp;hf)</PRE>
<DL>
<DD>Return a set of TaggedWord-TaggedWord dependencies, represented as
 Dependency objects for the Tree.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hf</CODE> - The HeadFinder to use to identify the head of constituents
<DT><B>Returns:</B><DD>Set of dependencies (each a <code>Dependency</code>)</DL>
</DD>
</DL>
<HR>

<A NAME="taggedDependencies(edu.stanford.nlp.util.Filter, edu.stanford.nlp.trees.HeadFinder)"><!-- --></A><H3>
taggedDependencies</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</A>&gt; <B>taggedDependencies</B>(<A HREF="../../../../edu/stanford/nlp/util/Filter.html" title="interface in edu.stanford.nlp.util">Filter</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</A>&gt;&nbsp;f,
                                          <A HREF="../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</A>&nbsp;hf)</PRE>
<DL>
<DD>Return a set of TaggedWord-TaggedWord dependencies, represented as
 Dependency objects, for the Tree.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>f</CODE> - Dependencies are excluded for which the Dependency is not
           accepted by the Filter<DD><CODE>hf</CODE> - The HeadFinder to use to identify the head of constituents.
           If this is <code>null</code>, then nodes are assumed to already
           be marked with their heads.
<DT><B>Returns:</B><DD>Set of dependencies (each a <code>Dependency</code>)</DL>
</DD>
</DL>
<HR>

<A NAME="mapDependencies(edu.stanford.nlp.util.Filter, edu.stanford.nlp.trees.HeadFinder)"><!-- --></A><H3>
mapDependencies</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</A>&gt; <B>mapDependencies</B>(<A HREF="../../../../edu/stanford/nlp/util/Filter.html" title="interface in edu.stanford.nlp.util">Filter</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</A>&gt;&nbsp;f,
                                       <A HREF="../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</A>&nbsp;hf)</PRE>
<DL>
<DD>Return a set of Label-Label dependencies, represented as
 Dependency objects, for the Tree.  The Labels are the ones of the leaf
 nodes of the tree, without mucking with them.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>f</CODE> - Dependencies are excluded for which the Dependency is not
           accepted by the Filter<DD><CODE>hf</CODE> - The HeadFinder to use to identify the head of constituents.
           The code assumes
           that it can use <code>headPreTerminal(hf)</code> to find a
           tag and word to make a CyclicCoreLabel.
<DT><B>Returns:</B><DD>Set of dependencies (each a <code>Dependency</code> between two
           <code>CyclicCoreLabel</code>s, which each contain a tag(), word(),
           and value(), the last two of which are identical).</DL>
</DD>
</DL>
<HR>

<A NAME="yield()"><!-- --></A><H3>
yield</H3>
<PRE>
public &lt;X extends <A HREF="../../../../edu/stanford/nlp/ling/HasWord.html" title="interface in edu.stanford.nlp.ling">HasWord</A>&gt; <A HREF="../../../../edu/stanford/nlp/ling/Sentence.html" title="class in edu.stanford.nlp.ling">Sentence</A>&lt;X&gt; <B>yield</B>()</PRE>
<DL>
<DD>Gets the yield of the tree.  The <code>Label</code> of all leaf nodes
 is returned
 as a list ordered by the natural left to right order of the
 leaves.  Null values, if any, are inserted into the list like any
 other value.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a <code>List</code> of the data in the tree's leaves.</DL>
</DD>
</DL>
<HR>

<A NAME="yield(edu.stanford.nlp.ling.Sentence)"><!-- --></A><H3>
yield</H3>
<PRE>
public &lt;X extends <A HREF="../../../../edu/stanford/nlp/ling/HasWord.html" title="interface in edu.stanford.nlp.ling">HasWord</A>&gt; <A HREF="../../../../edu/stanford/nlp/ling/Sentence.html" title="class in edu.stanford.nlp.ling">Sentence</A>&lt;X&gt; <B>yield</B>(<A HREF="../../../../edu/stanford/nlp/ling/Sentence.html" title="class in edu.stanford.nlp.ling">Sentence</A>&lt;X&gt;&nbsp;y)</PRE>
<DL>
<DD>Gets the yield of the tree.  The <code>Label</code> of all leaf nodes
 is returned
 as a list ordered by the natural left to right order of the
 leaves.  Null values, if any, are inserted into the list like any
 other value.
 <p><i>Implementation notes:</i> c. 2003: This has been rewritten to thread, so only one List
 is used. 2007: This method was duplicated to start to give type safety to Sentence.
 This method will now make a Word for any Leaf which does not itself implement HasWord, and
 put the Word into the Sentence, so the Sentence elements MUST implement HasWord.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>y</CODE> - The list in which the yield of the tree will be placed.
          Normally, this will be empty when the routine is called, but
          if not, the new yield is added to the end of the list.
<DT><B>Returns:</B><DD>a <code>List</code> of the data in the tree's leaves.</DL>
</DD>
</DL>
<HR>

<A NAME="yield(java.util.List)"><!-- --></A><H3>
yield</H3>
<PRE>
public &lt;T&gt; <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;T&gt; <B>yield</B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;T&gt;&nbsp;y)</PRE>
<DL>
<DD>Gets the yield of the tree.  The <code>Label</code> of all leaf nodes
 is returned
 as a list ordered by the natural left to right order of the
 leaves.  Null values, if any, are inserted into the list like any
 other value.  This has been rewritten to thread, so only one List
 is used.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>y</CODE> - The list in which the yield of the tree will be placed.
          Normally, this will be empty when the routine is called, but
          if not, the new yield is added to the end of the list.
<DT><B>Returns:</B><DD>a <code>List</code> of the data in the tree's leaves.</DL>
</DD>
</DL>
<HR>

<A NAME="taggedYield()"><!-- --></A><H3>
taggedYield</H3>
<PRE>
public <A HREF="../../../../edu/stanford/nlp/ling/Sentence.html" title="class in edu.stanford.nlp.ling">Sentence</A>&lt;<A HREF="../../../../edu/stanford/nlp/ling/TaggedWord.html" title="class in edu.stanford.nlp.ling">TaggedWord</A>&gt; <B>taggedYield</B>()</PRE>
<DL>
<DD>Gets the tagged yield of the tree.
 The <code>Label</code> of all leaf nodes is returned
 as a list ordered by the natural left to right order of the
 leaves.  Null values, if any, are inserted into the list like any
 other value.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a <code>List</code> of the data in the tree's leaves.</DL>
</DD>
</DL>
<HR>

<A NAME="labeledYield()"><!-- --></A><H3>
labeledYield</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;<A HREF="../../../../edu/stanford/nlp/ling/LabeledWord.html" title="class in edu.stanford.nlp.ling">LabeledWord</A>&gt; <B>labeledYield</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="taggedYield(java.util.List)"><!-- --></A><A NAME="taggedYield(X)"><!-- --></A><H3>
taggedYield</H3>
<PRE>
public &lt;X extends <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;<A HREF="../../../../edu/stanford/nlp/ling/TaggedWord.html" title="class in edu.stanford.nlp.ling">TaggedWord</A>&gt;&gt; X <B>taggedYield</B>(X&nbsp;ty)</PRE>
<DL>
<DD>Gets the tagged yield of the tree -- that is, get the preterminals
 as well as the terminals.  The <code>Label</code> of all leaf nodes
 is returned
 as a list ordered by the natural left to right order of the
 leaves.  Null values, if any, are inserted into the list like any
 other value.  This has been rewritten to thread, so only one List
 is used.
 <p/>
 <i>Implementation note:</i> when we summon up enough courage, this
 method will be changed to take and return a List<W extends TaggedWord>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ty</CODE> - The list in which the tagged yield of the tree will be
           placed. Normally, this will be empty when the routine is called,
           but if not, the new yield is added to the end of the list.
<DT><B>Returns:</B><DD>a <code>List</code> of the data in the tree's leaves.</DL>
</DD>
</DL>
<HR>

<A NAME="labeledYield(java.util.List)"><!-- --></A><H3>
labeledYield</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;<A HREF="../../../../edu/stanford/nlp/ling/LabeledWord.html" title="class in edu.stanford.nlp.ling">LabeledWord</A>&gt; <B>labeledYield</B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;<A HREF="../../../../edu/stanford/nlp/ling/LabeledWord.html" title="class in edu.stanford.nlp.ling">LabeledWord</A>&gt;&nbsp;ty)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="preTerminalYield()"><!-- --></A><H3>
preTerminalYield</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;<A HREF="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</A>&gt; <B>preTerminalYield</B>()</PRE>
<DL>
<DD>Gets the preterminal yield (i.e., tags) of the tree.  All data in
 preleaf nodes is returned as a list ordered by the natural left to
 right order of the tree.  Null values, if any, are inserted into the
 list like any other value.  Pre-leaves are nodes of height 1.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a <code>List</code> of the data in the tree's pre-leaves.</DL>
</DD>
</DL>
<HR>

<A NAME="preTerminalYield(java.util.List)"><!-- --></A><H3>
preTerminalYield</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;<A HREF="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</A>&gt; <B>preTerminalYield</B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;<A HREF="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</A>&gt;&nbsp;y)</PRE>
<DL>
<DD>Gets the preterminal yield (i.e., tags) of the tree.  All data in
 preleaf nodes is returned as a list ordered by the natural left to
 right order of the tree.  Null values, if any, are inserted into the
 list like any other value.  Pre-leaves are nodes of height 1.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>y</CODE> - The list in which the preterminals of the tree will be
          placed. Normally, this will be empty when the routine is called,
          but if not, the new yield is added to the end of the list.
<DT><B>Returns:</B><DD>a <code>List</code> of the data in the tree's pre-leaves.</DL>
</DD>
</DL>
<HR>

<A NAME="getLeaves()"><!-- --></A><H3>
getLeaves</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt; <B>getLeaves</B>()</PRE>
<DL>
<DD>Gets the leaves of the tree.  All leaves nodes are returned as a list
 ordered by the natural left to right order of the tree.  Null values,
 if any, are inserted into the list like any other value.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a <code>List</code> of the leaves.</DL>
</DD>
</DL>
<HR>

<A NAME="getLeaves(java.util.List)"><!-- --></A><H3>
getLeaves</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt; <B>getLeaves</B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;&nbsp;list)</PRE>
<DL>
<DD>Gets the leaves of the tree.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>list</CODE> - The list in which the leaves of the tree will be
             placed. Normally, this will be empty when the routine is called,
             but if not, the new yield is added to the end of the list.
<DT><B>Returns:</B><DD>a <code>List</code> of the leaves.</DL>
</DD>
</DL>
<HR>

<A NAME="labels()"><!-- --></A><H3>
labels</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Collection.html?is-external=true" title="class or interface in java.util">Collection</A>&lt;<A HREF="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</A>&gt; <B>labels</B>()</PRE>
<DL>
<DD>Get the set of all node and leaf <code>Label</code>s,
 null or otherwise, contained in the tree.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../edu/stanford/nlp/trees/Labeled.html#labels()">labels</A></CODE> in interface <CODE><A HREF="../../../../edu/stanford/nlp/trees/Labeled.html" title="interface in edu.stanford.nlp.trees">Labeled</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the <code>Collection</code> (actually, Set) of all values
         in the tree.</DL>
</DD>
</DL>
<HR>

<A NAME="setLabels(java.util.Collection)"><!-- --></A><H3>
setLabels</H3>
<PRE>
public void <B>setLabels</B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Collection.html?is-external=true" title="class or interface in java.util">Collection</A>&lt;<A HREF="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</A>&gt;&nbsp;c)</PRE>
<DL>
<DD><B>Description copied from interface: <CODE><A HREF="../../../../edu/stanford/nlp/trees/Labeled.html#setLabels(java.util.Collection)">Labeled</A></CODE></B></DD>
<DD>Sets the labels associated with this object.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../edu/stanford/nlp/trees/Labeled.html#setLabels(java.util.Collection)">setLabels</A></CODE> in interface <CODE><A HREF="../../../../edu/stanford/nlp/trees/Labeled.html" title="interface in edu.stanford.nlp.trees">Labeled</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c</CODE> - The set of Label values</DL>
</DD>
</DL>
<HR>

<A NAME="flatten()"><!-- --></A><H3>
flatten</H3>
<PRE>
public <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> <B>flatten</B>()</PRE>
<DL>
<DD>Return a flattened version of a tree.  In many circumstances, this
 will just return the tree, but if the tree is something like a
 binarized version of a dependency grammar tree, then it will be
 flattened back to a dependency grammar tree representation.  Formally,
 a node will be removed from the tree when: it is not a terminal or
 preterminal, and its <code>label()</code is <code>equal()</code> to
 the <code>label()</code> of its parent, and all its children will
 then be promoted to become children of the parent (in the same
 position in the sequence of daughters.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>A flattened version of this tree.</DL>
</DD>
</DL>
<HR>

<A NAME="flatten(edu.stanford.nlp.trees.TreeFactory)"><!-- --></A><H3>
flatten</H3>
<PRE>
public <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> <B>flatten</B>(<A HREF="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</A>&nbsp;tf)</PRE>
<DL>
<DD>Return a flattened version of a tree.  In many circumstances, this
 will just return the tree, but if the tree is something like a
 binarized version of a dependency grammar tree, then it will be
 flattened back to a dependency grammar tree representation.  Formally,
 a node will be removed from the tree when: it is not a terminal or
 preterminal, and its <code>label()</code is <code>equal()</code> to
 the <code>label()</code> of its parent, and all its children will
 then be promoted to become children of the parent (in the same
 position in the sequence of daughters. <p>
 Note: In the current implementation, the tree structure is mainly
 duplicated, but the links between preterminals and terminals aren't.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tf</CODE> - TreeFactory used to create tree structure for flattened tree
<DT><B>Returns:</B><DD>A flattened version of this tree.</DL>
</DD>
</DL>
<HR>

<A NAME="subTrees()"><!-- --></A><H3>
subTrees</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt; <B>subTrees</B>()</PRE>
<DL>
<DD>Get the set of all subtrees inside the tree by returning a tree
 rooted at each node.  These are <i>not</i> copies, but all share
 structure.  The tree is regarded as a subtree of itself.
 <p/>
 <i>Note:</i> If you only want to form this Set so that you can
 iterate over it, it is more efficient to simply use the Tree class's
 own <code>iterator() method. This will iterate over the exact same
 elements (but perhaps/probably in a different order).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the <code>Set</code> of all subtrees in the tree.</DL>
</DD>
</DL>
<HR>

<A NAME="subTreeList()"><!-- --></A><H3>
subTreeList</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt; <B>subTreeList</B>()</PRE>
<DL>
<DD>Get the list of all subtrees inside the tree by returning a tree
 rooted at each node.  These are <i>not</i> copies, but all share
 structure.  The tree is regarded as a subtree of itself.
 <p/>
 <i>Note:</i> If you only want to form this Collection so that you can
 iterate over it, it is more efficient to simply use the Tree class's
 own <code>iterator() method. This will iterate over the exact same
 elements (but perhaps/probably in a different order).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the <code>List</code> of all subtrees in the tree.</DL>
</DD>
</DL>
<HR>

<A NAME="subTrees(java.util.Collection)"><!-- --></A><A NAME="subTrees(T)"><!-- --></A><H3>
subTrees</H3>
<PRE>
public &lt;T extends <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Collection.html?is-external=true" title="class or interface in java.util">Collection</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;&gt; T <B>subTrees</B>(T&nbsp;n)</PRE>
<DL>
<DD>Add the set of all subtrees inside a tree (including the tree itself)
 to the given <code>Collection</code>.
 <p/>
 <i>Note:</i> If you only want to form this Collection so that you can
 iterate over it, it is more efficient to simply use the Tree class's
 own <code>iterator() method. This will iterate over the exact same
 elements (but perhaps/probably in a different order).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - A collection of nodes to which the subtrees will be added.
<DT><B>Returns:</B><DD>The collection parameter with the subtrees added.</DL>
</DD>
</DL>
<HR>

<A NAME="deeperCopy()"><!-- --></A><H3>
deeperCopy</H3>
<PRE>
public <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> <B>deeperCopy</B>()</PRE>
<DL>
<DD>Same as deepCopy but makes a copy of the labels as well.
 Uses the TreeFactory of the root node given by treeFactory().
 Assumes that your labels give a non-null labelFactory().
 (Added by Aria Haghighi.)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>A deep copy of the tree structure and its labels</DL>
</DD>
</DL>
<HR>

<A NAME="deeperCopy(edu.stanford.nlp.trees.TreeFactory)"><!-- --></A><H3>
deeperCopy</H3>
<PRE>
public <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> <B>deeperCopy</B>(<A HREF="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</A>&nbsp;tf)</PRE>
<DL>
<DD>Same as deepCopy but makes a copy of the labels as well.
 Each Label is copied using the labelFactory() returned
 by the corresponding node's label.
 It assumes that your labels give non-null labelFactory.
 (Added by Aria Haghighi.)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tf</CODE> - The TreeFactory used to make all nodes in the copied
           tree structure
<DT><B>Returns:</B><DD>A Tree that is a deep copy of the tree structure and
         Labels of the original tree.</DL>
</DD>
</DL>
<HR>

<A NAME="deeperCopy(edu.stanford.nlp.trees.TreeFactory, edu.stanford.nlp.ling.LabelFactory)"><!-- --></A><H3>
deeperCopy</H3>
<PRE>
public <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> <B>deeperCopy</B>(<A HREF="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</A>&nbsp;tf,
                       <A HREF="../../../../edu/stanford/nlp/ling/LabelFactory.html" title="interface in edu.stanford.nlp.ling">LabelFactory</A>&nbsp;lf)</PRE>
<DL>
<DD>Same as deepCopy but will copy the labels over as well.
 Each tree is copied with the given TreeFactory.
 Each Label is copied using the given LabelFactory.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tf</CODE> - The TreeFactory used to make all nodes in the copied
           tree structure<DD><CODE>lf</CODE> - The LabelFactory used to make all nodes in the copied
           tree structure
<DT><B>Returns:</B><DD>A Tree that is a deep copy of the tree structure and
         Labels of the original tree.</DL>
</DD>
</DL>
<HR>

<A NAME="deepCopy()"><!-- --></A><H3>
deepCopy</H3>
<PRE>
public <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> <B>deepCopy</B>()</PRE>
<DL>
<DD>Create a deep copy of the tree.  The entire structure is
 recursively copied, but label data themselves are not cloned.
 The copy is built using a <code>TreeFactory</code> that will
 produce a <code>Tree</code> like the input one.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a deep structural copy of the tree.</DL>
</DD>
</DL>
<HR>

<A NAME="deepCopy(edu.stanford.nlp.trees.TreeFactory)"><!-- --></A><H3>
deepCopy</H3>
<PRE>
public <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> <B>deepCopy</B>(<A HREF="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</A>&nbsp;tf)</PRE>
<DL>
<DD>Create a deep copy of the tree.  The entire structure is
 recursively copied, but label data themselves are not cloned.
 By specifying an appropriate <code>TreeFactory</code>, this
 method can be used to change the type of a <code>Tree</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tf</CODE> - The <code>TreeFactory</code> to be used for creating
           the returned <code>Tree</code>
<DT><B>Returns:</B><DD>a deep structural copy of the tree.</DL>
</DD>
</DL>
<HR>

<A NAME="transform(edu.stanford.nlp.trees.TreeTransformer)"><!-- --></A><H3>
transform</H3>
<PRE>
public <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> <B>transform</B>(<A HREF="../../../../edu/stanford/nlp/trees/TreeTransformer.html" title="interface in edu.stanford.nlp.trees">TreeTransformer</A>&nbsp;transformer)</PRE>
<DL>
<DD>Create a transformed Tree.  The tree is traversed in a depth-first,
 left-to-right order, and the <code>TreeTransformer</code> is called
 on each node.  It returns some <code>Tree</code>.  The transformed
 tree has a new tree structure (i.e., a "deep copy" is done), but it
 will usually share its labels with the original tree.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>transformer</CODE> - The function that transforms tree nodes or subtrees
<DT><B>Returns:</B><DD>a transformation of this <code>Tree</code></DL>
</DD>
</DL>
<HR>

<A NAME="transform(edu.stanford.nlp.trees.TreeTransformer, edu.stanford.nlp.trees.TreeFactory)"><!-- --></A><H3>
transform</H3>
<PRE>
public <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> <B>transform</B>(<A HREF="../../../../edu/stanford/nlp/trees/TreeTransformer.html" title="interface in edu.stanford.nlp.trees">TreeTransformer</A>&nbsp;transformer,
                      <A HREF="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</A>&nbsp;tf)</PRE>
<DL>
<DD>Create a transformed Tree.  The tree is traversed in a depth-first,
 left-to-right order, and the <code>TreeTransformer</code> is called
 on each node.  It returns some <code>Tree</code>.  The transformed
 tree has a new tree structure (i.e., a "deep copy" is done), but it
 will usually share its labels with the original tree.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>transformer</CODE> - The function that transforms tree nodes or subtrees<DD><CODE>tf</CODE> - The <code>TreeFactory</code> which will be used for creating
                    new nodes for the returned <code>Tree</code>
<DT><B>Returns:</B><DD>a transformation of this <code>Tree</code></DL>
</DD>
</DL>
<HR>

<A NAME="spliceOut(edu.stanford.nlp.util.Filter)"><!-- --></A><H3>
spliceOut</H3>
<PRE>
public <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> <B>spliceOut</B>(<A HREF="../../../../edu/stanford/nlp/util/Filter.html" title="interface in edu.stanford.nlp.util">Filter</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;&nbsp;nodeFilter)</PRE>
<DL>
<DD>Creates a (partial) deep copy of the tree, where all nodes that the
 filter does not accept are spliced out.  If the result is not a tree
 (that is, it's a forest), an empty root node is generated.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>nodeFilter</CODE> - a Filter method which returns true to mean
                   keep this node, false to mean delete it
<DT><B>Returns:</B><DD>a filtered copy of the tree</DL>
</DD>
</DL>
<HR>

<A NAME="spliceOut(edu.stanford.nlp.util.Filter, edu.stanford.nlp.trees.TreeFactory)"><!-- --></A><H3>
spliceOut</H3>
<PRE>
public <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> <B>spliceOut</B>(<A HREF="../../../../edu/stanford/nlp/util/Filter.html" title="interface in edu.stanford.nlp.util">Filter</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;&nbsp;nodeFilter,
                      <A HREF="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</A>&nbsp;tf)</PRE>
<DL>
<DD>Creates a (partial) deep copy of the tree, where all nodes that the
 filter does not accept are spliced out.  That is, the particular
 modes for which the <code>Filter</code> returns <code>false</code>
 are removed from the <code>Tree</code>, but those nodes' children
 are kept (assuming they pass the <code>Filter</code>, and they are
 added in the appropriate left-to-right ordering as new children of
 the parent node.  If the root node is deleted, so that the result
 would not be a tree (that is, it's a forest), an empty root node is
 generated.  If nothing is accepted, <code>null</code> is returned.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>nodeFilter</CODE> - a Filter method which returns true to mean
                   keep this node, false to mean delete it<DD><CODE>tf</CODE> - A <code>TreeFactory</code> for making new trees. Used if
                   the root node is deleted.
<DT><B>Returns:</B><DD>a filtered copy of the tree.</DL>
</DD>
</DL>
<HR>

<A NAME="prune(edu.stanford.nlp.util.Filter)"><!-- --></A><H3>
prune</H3>
<PRE>
public <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> <B>prune</B>(<A HREF="../../../../edu/stanford/nlp/util/Filter.html" title="interface in edu.stanford.nlp.util">Filter</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;&nbsp;filter)</PRE>
<DL>
<DD>Creates a deep copy of the tree, where all nodes that the filter
 does not accept and all children of such nodes are pruned.  If all '
 of a node's children are pruned, that node is cut as well.
 A <code>Filter</code> can assume
 that it will not be called with a <code>null</code> argument.
 <p/>
 For example, the following code excises all PP nodes from a Tree:
 <tt>
 Filter<Tree> f = new Filter<Tree> {
 public boolean accept(Tree t) {
 return ! t.label().value().equals("PP");
 }
 }
 tree.prune(f);
 </tt>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>filter</CODE> - the filter to be apply
<DT><B>Returns:</B><DD>a filtered copy of the tree.</DL>
</DD>
</DL>
<HR>

<A NAME="prune(edu.stanford.nlp.util.Filter, edu.stanford.nlp.trees.TreeFactory)"><!-- --></A><H3>
prune</H3>
<PRE>
public <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> <B>prune</B>(<A HREF="../../../../edu/stanford/nlp/util/Filter.html" title="interface in edu.stanford.nlp.util">Filter</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;&nbsp;filter,
                  <A HREF="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</A>&nbsp;tf)</PRE>
<DL>
<DD>Creates a deep copy of the tree, where all nodes that the filter
 does not accept and all children of such nodes are pruned.  If all
 of a node's children are pruned, that node is cut as well.
 A <code>Filter</code> can assume
 that it will not be called with a <code>null</code> argument.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>filter</CODE> - the filter to be apply<DD><CODE>tf</CODE> - the TreeFactory to be used to make new Tree nodes if needed
<DT><B>Returns:</B><DD>a filtered copy of the tree, including the possibility of
         <code>null</code> if the root node of the tree is filtered</DL>
</DD>
</DL>
<HR>

<A NAME="treeFactory()"><!-- --></A><H3>
treeFactory</H3>
<PRE>
public abstract <A HREF="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</A> <B>treeFactory</B>()</PRE>
<DL>
<DD>Return a <code>TreeFactory</code> that produces trees of the
 appropriate type.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>A factory to produce Trees</DL>
</DD>
</DL>
<HR>

<A NAME="parent()"><!-- --></A><H3>
parent</H3>
<PRE>
public <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> <B>parent</B>()</PRE>
<DL>
<DD>Return the parent of the tree node.  This routine may return
 <code>null</code> meaning simply that the implementation doesn't
 know how to determine the parent node, rather than there is no
 such node.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The parent <code>Tree</code> node or <code>null</code><DT><B>See Also:</B><DD><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#parent(edu.stanford.nlp.trees.Tree)"><CODE>parent(Tree)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="parent(edu.stanford.nlp.trees.Tree)"><!-- --></A><H3>
parent</H3>
<PRE>
public <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> <B>parent</B>(<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;root)</PRE>
<DL>
<DD>Return the parent of the tree node.  This routine will traverse
 a tree (depth first) from the given <code>root</code>, and will
 correctly find the parent, regardless of whether the concrete
 class stores parents.  It will only return <code>null</code> if this
 node is the <code>root</code> node, or if this node is not
 contained within the tree rooted at <code>root</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>root</CODE> - The root node of the whole Tree
<DT><B>Returns:</B><DD>the parent <code>Tree</code> node if any;
         else <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="size()"><!-- --></A><H3>
size</H3>
<PRE>
public int <B>size</B>()</PRE>
<DL>
<DD>Returns the number of nodes the tree contains.  This method
 implements the <code>size()</code> function required by the
 <code>Collections</code> interface.  The size of the tree is the
 number of nodes it contains (of all types, including the leaf nodes
 and the root).
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Collection.html?is-external=true#size()" title="class or interface in java.util">size</A></CODE> in interface <CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Collection.html?is-external=true" title="class or interface in java.util">Collection</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;</CODE><DT><B>Specified by:</B><DD><CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractCollection.html?is-external=true#size()" title="class or interface in java.util">size</A></CODE> in class <CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractCollection.html?is-external=true" title="class or interface in java.util">AbstractCollection</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The size of the tree<DT><B>See Also:</B><DD><A HREF="../../../../edu/stanford/nlp/trees/Tree.html#depth()"><CODE>depth()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="ancestor(int, edu.stanford.nlp.trees.Tree)"><!-- --></A><H3>
ancestor</H3>
<PRE>
public <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> <B>ancestor</B>(int&nbsp;height,
                     <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;root)</PRE>
<DL>
<DD>Return the ancestor tree node <code>height</code> nodes up from the current node.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>height</CODE> - How many nodes up to go. A parameter of 0 means return
               this node, 1 means to return the parent node and so on.<DD><CODE>root</CODE> - The root node that this Tree is embedded under
<DT><B>Returns:</B><DD>The ancestor at height <code>height</code>.  It returns null
         if it does not exist or the tree implementation does not keep track
         of parents</DL>
</DD>
</DL>
<HR>

<A NAME="iterator()"><!-- --></A><H3>
iterator</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Iterator.html?is-external=true" title="class or interface in java.util">Iterator</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt; <B>iterator</B>()</PRE>
<DL>
<DD>Returns an iterator over all the nodes of the tree.  This method
 implements the <code>iterator()</code> method required by the
 <code>Collections</code> interface.  It does a preorder
 (children after node) traversal of the tree.  (A possible
 extension to the class at some point would be to allow different
 traversal orderings via variant iterators.)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Iterable.html?is-external=true#iterator()" title="class or interface in java.lang">iterator</A></CODE> in interface <CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Iterable.html?is-external=true" title="class or interface in java.lang">Iterable</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;</CODE><DT><B>Specified by:</B><DD><CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Collection.html?is-external=true#iterator()" title="class or interface in java.util">iterator</A></CODE> in interface <CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Collection.html?is-external=true" title="class or interface in java.util">Collection</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;</CODE><DT><B>Specified by:</B><DD><CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractCollection.html?is-external=true#iterator()" title="class or interface in java.util">iterator</A></CODE> in class <CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractCollection.html?is-external=true" title="class or interface in java.util">AbstractCollection</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt;</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>An interator over the nodes of the tree</DL>
</DD>
</DL>
<HR>

<A NAME="valueOf(java.lang.String)"><!-- --></A><H3>
valueOf</H3>
<PRE>
public static <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> <B>valueOf</B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;str)
                    throws <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>This gives you a tree from a String representation (as a
 bracketed Tree, of the kind produced by <code>toString()</code>,
 <code>pennPrint()</code>, or as in the Penn Treebank).
 It's not the most efficient thing to do for heavy duty usage.
 The Tree returned is created by a
 StringLabeledScoredTreeReaderFactory.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>str</CODE> - The tree as a bracketed list in a String.
<DT><B>Returns:</B><DD>The Tree
<DT><B>Throws:</B>
<DD><CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE> - If Tree format is not valid</DL>
</DD>
</DL>
<HR>

<A NAME="valueOf(java.lang.String, edu.stanford.nlp.trees.TreeReaderFactory)"><!-- --></A><H3>
valueOf</H3>
<PRE>
public static <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> <B>valueOf</B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;str,
                           <A HREF="../../../../edu/stanford/nlp/trees/TreeReaderFactory.html" title="interface in edu.stanford.nlp.trees">TreeReaderFactory</A>&nbsp;trf)
                    throws <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>This gives you a tree from a String representation (as a
 bracketed Tree, of the kind produced by <code>toString()</code>,
 <code>pennPrint()</code>, or as in the Penn Treebank.
 It's not the most efficient thing to do for heavy duty usage.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>str</CODE> - The tree as a bracketed list in a String.<DD><CODE>trf</CODE> - The TreeFactory used to make the new Tree
<DT><B>Returns:</B><DD>The Tree
<DT><B>Throws:</B>
<DD><CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE> - If Tree format is not valid</DL>
</DD>
</DL>
<HR>

<A NAME="getChild(int)"><!-- --></A><H3>
getChild</H3>
<PRE>
public <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> <B>getChild</B>(int&nbsp;i)</PRE>
<DL>
<DD>Return the child at some daughter index.  The children are numbered
 starting with an index of 0.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>i</CODE> - The daughter index
<DT><B>Returns:</B><DD>The tree at that daughter index</DL>
</DD>
</DL>
<HR>

<A NAME="removeChild(int)"><!-- --></A><H3>
removeChild</H3>
<PRE>
public <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> <B>removeChild</B>(int&nbsp;i)</PRE>
<DL>
<DD>Destructively removes the child at some daughter index and returns it.
 Note
 that this method will throw an <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/ArrayIndexOutOfBoundsException.html?is-external=true" title="class or interface in java.lang"><CODE>ArrayIndexOutOfBoundsException</CODE></A> if
 the daughter index is too big for the list of daughters.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>i</CODE> - The daughter index
<DT><B>Returns:</B><DD>The tree at that daughter index</DL>
</DD>
</DL>
<HR>

<A NAME="addChild(int, edu.stanford.nlp.trees.Tree)"><!-- --></A><H3>
addChild</H3>
<PRE>
public void <B>addChild</B>(int&nbsp;i,
                     <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;t)</PRE>
<DL>
<DD>Adds the tree t at the index position among the daughters.  Note
 that this method will throw an <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/ArrayIndexOutOfBoundsException.html?is-external=true" title="class or interface in java.lang"><CODE>ArrayIndexOutOfBoundsException</CODE></A> if
 the the daughter index is too big for the list of daughters.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>i</CODE> - the index position at which to add the new daughter<DD><CODE>t</CODE> - the new daughter</DL>
</DD>
</DL>
<HR>

<A NAME="addChild(edu.stanford.nlp.trees.Tree)"><!-- --></A><H3>
addChild</H3>
<PRE>
public void <B>addChild</B>(<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;t)</PRE>
<DL>
<DD>Adds the tree t at the last index position among the daughters.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t</CODE> - the new daughter</DL>
</DD>
</DL>
<HR>

<A NAME="setChild(int, edu.stanford.nlp.trees.Tree)"><!-- --></A><H3>
setChild</H3>
<PRE>
public <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> <B>setChild</B>(int&nbsp;i,
                     <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;t)</PRE>
<DL>
<DD>Replaces the <code>i</code>th child of <code>this</code> with the tree t.
 Note
 that this method will throw an <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/ArrayIndexOutOfBoundsException.html?is-external=true" title="class or interface in java.lang"><CODE>ArrayIndexOutOfBoundsException</CODE></A> if
 the child index is too big for the list of children.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>i</CODE> - The index position at which to replace the child<DD><CODE>t</CODE> - The new child
<DT><B>Returns:</B><DD>The tree that was previously the ith d</DL>
</DD>
</DL>
<HR>

<A NAME="dominates(edu.stanford.nlp.trees.Tree)"><!-- --></A><H3>
dominates</H3>
<PRE>
public boolean <B>dominates</B>(<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;t)</PRE>
<DL>
<DD>Returns true if <code>this</code> dominates the Tree passed in
 as an argument.  Object equality (==) rather than .equals() is used
 to determine domination.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="dominationPath(edu.stanford.nlp.trees.Tree)"><!-- --></A><H3>
dominationPath</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt; <B>dominationPath</B>(<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;t)</PRE>
<DL>
<DD>Returns the path of nodes leading down to a dominated node,
 including <code>this</code> and the dominated node itself.
 Returns null if t is not dominated by <code>this</code>.  Object
 equality (==) is the relevant criterion.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="pathNodeToNode(edu.stanford.nlp.trees.Tree, edu.stanford.nlp.trees.Tree)"><!-- --></A><H3>
pathNodeToNode</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt; <B>pathNodeToNode</B>(<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;t1,
                                 <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;t2)</PRE>
<DL>
<DD>Given nodes <code>t1</code> and <code>t2</code> which are
 dominated by this node, returns a list of all the nodes on the
 path from t1 to t2, inclusive, or null if none found.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="joinNode(edu.stanford.nlp.trees.Tree, edu.stanford.nlp.trees.Tree)"><!-- --></A><H3>
joinNode</H3>
<PRE>
public <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> <B>joinNode</B>(<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;t1,
                     <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;t2)</PRE>
<DL>
<DD>Given nodes <code>t1</code> and <code>t2</code> which are
 dominated by this node, returns their "join node": the node
 <code>j</code> such that <code>j</code> dominates both
 <code>t1</code> and <code>t2</code>, and no other node which
 also dominates both <code>t1</code> and <code>t2</code>
 dominates <code>j</code>.  (Remember that domination is defined
 such that every node dominates itself.)  Returns
 <code>null</code> if no such node can be found.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cCommands(edu.stanford.nlp.trees.Tree, edu.stanford.nlp.trees.Tree)"><!-- --></A><H3>
cCommands</H3>
<PRE>
public boolean <B>cCommands</B>(<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;t1,
                         <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;t2)</PRE>
<DL>
<DD>Given nodes <code>t1</code> and <code>t2</code> which are
 dominated by this node, returns <code>true</code> iff
 <code>t1</code> c-commands <code>t2</code>.  (A node c-commands
 its sister(s) and any nodes below its sister(s).)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="siblings(edu.stanford.nlp.trees.Tree)"><!-- --></A><H3>
siblings</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</A>&lt;<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt; <B>siblings</B>(<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;root)</PRE>
<DL>
<DD>Returns the siblings of this Tree node.  The siblings are all
 children of the parent of this node except this node.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>root</CODE> - The root within which this tree node is contained
<DT><B>Returns:</B><DD>The siblings as a list, an empty list if there are no siblings.
   The returned list is a modifiable new list structure, but contains
   the actual children.</DL>
</DD>
</DL>
<HR>

<A NAME="insertDtr(edu.stanford.nlp.trees.Tree, int)"><!-- --></A><H3>
insertDtr</H3>
<PRE>
public void <B>insertDtr</B>(<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;dtr,
                      int&nbsp;position)</PRE>
<DL>
<DD>insert <code>dtr</code> after <code>position</code> existing
 daughters in <code>this</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="value()"><!-- --></A><H3>
value</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A> <B>value</B>()</PRE>
<DL>
<DD><B>Description copied from interface: <CODE><A HREF="../../../../edu/stanford/nlp/ling/Label.html#value()">Label</A></CODE></B></DD>
<DD>Return a String representation of just the "main" value of this label.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../edu/stanford/nlp/ling/Label.html#value()">value</A></CODE> in interface <CODE><A HREF="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the "value" of the label</DL>
</DD>
</DL>
<HR>

<A NAME="setValue(java.lang.String)"><!-- --></A><H3>
setValue</H3>
<PRE>
public void <B>setValue</B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;value)</PRE>
<DL>
<DD><B>Description copied from interface: <CODE><A HREF="../../../../edu/stanford/nlp/ling/Label.html#setValue(java.lang.String)">Label</A></CODE></B></DD>
<DD>Set the value for the label (if one is stored).
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../edu/stanford/nlp/ling/Label.html#setValue(java.lang.String)">setValue</A></CODE> in interface <CODE><A HREF="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - - the value for the label</DL>
</DD>
</DL>
<HR>

<A NAME="setFromString(java.lang.String)"><!-- --></A><H3>
setFromString</H3>
<PRE>
public void <B>setFromString</B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;labelStr)</PRE>
<DL>
<DD><B>Description copied from interface: <CODE><A HREF="../../../../edu/stanford/nlp/ling/Label.html#setFromString(java.lang.String)">Label</A></CODE></B></DD>
<DD>Set the contents of this label to this <code>String</code>
 representing the
 complete contents of the label.  A class implementing label may
 throw an <code>UnsupportedOperationException</code> for this
 method (only).  Typically, this method would do
 some appropriate decoding of the string in a way that sets
 multiple fields in an inverse of the <code>toString()</code>
 method.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../edu/stanford/nlp/ling/Label.html#setFromString(java.lang.String)">setFromString</A></CODE> in interface <CODE><A HREF="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>labelStr</CODE> - the String that translates into the content of the
                 label</DL>
</DD>
</DL>
<HR>

<A NAME="labelFactory()"><!-- --></A><H3>
labelFactory</H3>
<PRE>
public <A HREF="../../../../edu/stanford/nlp/ling/LabelFactory.html" title="interface in edu.stanford.nlp.ling">LabelFactory</A> <B>labelFactory</B>()</PRE>
<DL>
<DD>Returns a factory that makes labels of the same type as this one.
 May return <code>null</code> if no appropriate factory is known.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../edu/stanford/nlp/ling/Label.html#labelFactory()">labelFactory</A></CODE> in interface <CODE><A HREF="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the LabelFactory for this kind of label</DL>
</DD>
</DL>
<HR>

<A NAME="leftCharEdge(edu.stanford.nlp.trees.Tree)"><!-- --></A><H3>
leftCharEdge</H3>
<PRE>
public int <B>leftCharEdge</B>(<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;node)</PRE>
<DL>
<DD>Returns the positional index of the left edge of  <i>node</i> within the tree,
 as measured by characters.  Returns -1 if <i>node is not found.</i>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="rightCharEdge(edu.stanford.nlp.trees.Tree)"><!-- --></A><H3>
rightCharEdge</H3>
<PRE>
public int <B>rightCharEdge</B>(<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;node)</PRE>
<DL>
<DD>Returns the positional index of the right edge of  <i>node</i> within the tree,
 as measured by characters. Returns -1 if <i>node is not found.</i>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>node</CODE> - The subtree to look for in this Tree
<DT><B>Returns:</B><DD>The positional index of the right edge of node</DL>
</DD>
</DL>
<HR>

<A NAME="nodeNumber(edu.stanford.nlp.trees.Tree)"><!-- --></A><H3>
nodeNumber</H3>
<PRE>
public int <B>nodeNumber</B>(<A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;root)</PRE>
<DL>
<DD>Calculates the node's <i>number</i>, defined as the number of nodes traversed in a left-to-right, depth-first search of the
 tree starting at <code>root</code> and ending at <code>this</code>.  Returns -1 if <code>root</code> does not contain <code>this</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>root</CODE> - the root node of the relevant tree
<DT><B>Returns:</B><DD>the number of the current node, or -1 if <code>root</code> does not contain <code>this</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="getNodeNumber(int)"><!-- --></A><H3>
getNodeNumber</H3>
<PRE>
public <A HREF="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> <B>getNodeNumber</B>(int&nbsp;i)</PRE>
<DL>
<DD>Fetches the <code>i</code>th node in the tree, with node numbers defined
 as in <A HREF="../../../../edu/stanford/nlp/trees/Tree.html#nodeNumber(edu.stanford.nlp.trees.Tree)"><CODE>nodeNumber(Tree)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>i</CODE> - the node number to fetch
<DT><B>Returns:</B><DD>the <code>i</code>th node in the tree
<DT><B>Throws:</B>
<DD><CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/IndexOutOfBoundsException.html?is-external=true" title="class or interface in java.lang">IndexOutOfBoundsException</A></CODE> - if <code>i</code> is not between 1 and
    the number of nodes (inclusive) contained in <code>this</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="indexLeaves()"><!-- --></A><H3>
indexLeaves</H3>
<PRE>
public void <B>indexLeaves</B>()</PRE>
<DL>
<DD>Assign sequential integer indices to the leaves of the tree
 rooted at this <code>Tree</code>, starting with 1.
 The leaves are traversed from left
 to right. If the node is already indexed, then it uses the existing index.
 This will only work if the leaves extend CoreMap.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/StringLabeledScoredTreeReaderFactory.html" title="class in edu.stanford.nlp.trees"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../edu/stanford/nlp/trees/TreeCoreAnnotations.html" title="class in edu.stanford.nlp.trees"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?edu/stanford/nlp/trees/Tree.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Tree.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<FONT SIZE=2><A HREF="http://nlp.stanford.edu">Stanford NLP Group</A></FONT>
</BODY>
</HTML>
